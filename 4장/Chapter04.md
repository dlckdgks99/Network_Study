# 4.1 다중처리 기술

### 멀티태스킹
- 여러 작업을 병행하여 처리하는 기법
- 멀티 프로세스
  - 각 프로세스들이 독립적으로 작업을 처리하므로 구현이 간편
  - 병렬처리 해야 할 작업 수만큼 프로세스를 생성하여하 하는 단점
  - 프로세스가 많이 생성될수록 메모리 사용량이 증가하고 스케줄링 횟수도 많아져 프로그램 성능이 떨어짐
  - 프로세스들 사이에 데이터 공유하기 불편
  - 데이터 공유하려면 IPC 통신이 필요해 구현 복잡
- 멀티 스레드
  - 프로세스 내에서 독립적으로 실행되는 작업 단위
  - 새로 만들어진 스레드는 원래 프로세스의 이미지를 같이 사용(공유)
  - 스레드용 스택 영역은 스레드별로 별도로 배정(스택 공유 x)
  - 한 프로세스 내에서 생성된 스레드들은 이미지를 공유(전역변수를 같이 사용)
  - 메모리량 절약 및 생성 시간 짧음
  - 동기화 문제가 발생
 
### 다중화

| 방식  | 작동 방식 | 장점| 단점| 사용 예|
| ------------- | ------------- |------------- |------------- |------------- |
| 폴링  | CPU가 계속 상태 확인 | 구현 쉬움| CPU 낭비 극심| 단순 I/O|
| 셀렉팅  | OS가 준비된 소켓을 알려줌 | 효율적, 서버개발에 주로사용| select,poll은 성능 한계| tcp 서버, 채팅서버|
| 인터럽트  | 장치가 먼저 CPU 깨움 | 가장 효율적| 구현 복잡| 키보드 등 하드웨어|

### 다중처리 예
- 채팅 프로그램
- 멀티프로세스형 서버 프로그램
- 폴링형 서버 프로그램
- 셀렉팅형 서버 프로그램
- 인터럽트형 서버 프로그램

# 4.2 소켓의 동작 모드
- 블록 모드 : 이 소켓에 대해 시스템 콜을 호출하였을 때 시스템이 동작을 완료할때까지 시스템 콜에서 프로세스가 멈추어있는 모드
- 넌블록 모드 : 소켓 관련 시스템 콜에 대하여 시스템이 즉시 처리할 수 있으면 바로 결과를 리턴하고, 즉시 처리할 수 없는 경우라도 시스템 콜이 바로 리턴되어 응용프로그램이 블록되지 않게 하는 소켓
- 비동기 모드 : 소켓에서 어떤 I/O 변화가 발생하면 그 사실을 응용 프로그램이 알 수 있도록하여 그 때 입출력 처리 등 원하는 동작을 하는 모드

# 4.3 비동기형 채팅 프로그램

### 채팅 서버 프로그램 구조

### select()
- 설렉팅 처리함수
- 함수 자체는 블록형 함수 => 아무런 입출력 변화가 없으면 프로그램은 select()에서 블록
- 단점
  - 감시할 FD가 많아질수록 성능이 느려짐
  - FD_SET을 매번 초기화하고 복사해야 해서 오버헤드가 큼
  - FD 개수 상한: 1024개 (기본 FD_SETSIZE)

### 채팅 서버 프로그램
- 이벤트 기반 비동기형 (select) IO 멀티플렉싱 서버
- tcp_chatcli.c
  - 내가 채팅을 쳤다 => 키보드 이벤트 발생(0), FD_ISSET(0) = true, 키보드 처리 if문만 실행됨
  - 다른 클라이언트가 채팅을 쳤다 => 서버 메시지 도착(s), FD_ISSET(s) = true, 서버 메시지 처리 if문만 실행됨
 
# 4.4 폴링형 채팅 프로그램
### fcntl()
- 이 시스템콜을 사용하여 소켓을 넌블록 모드나 비동기 모드로 변경할 수 있음
- 소켓의 소유자를 설정하거나 현재 소유자를 얻어옴
- file control을 의미
- 함수인자
  - F_SETFL :프래그 세트
  - F_GETFL : 프래그 읽기
  - F_SETOWN : 소켓의 소유자를 설정
  - F_GETOWN : 현재 소켓의 소유자를 얻어옴
    
### 폴링형 채팅 서버
- 소켓들을 fcntl()을 이용하여 넌블록 모드로 설정한 후 무한루프를 돌면서 입출력을 폴링 방식으로 처리
## 비동기형 채팅(이벤트 기반) vs 폴링형 채팅 비교

| 구분 | 비동기형 채팅 (Async / Event-driven) | 폴링형 채팅 (Polling) |
|------|--------------------------------------|------------------------|
| 메시지 처리 방식 | 데이터가 오면 **즉시 이벤트 발생** | 일정 시간마다 **반복 검사** |
| CPU 사용량 | 낮음 (불필요한 연산 없음) | 높음 (계속 검사해야 함) |
| 지연 시간(Delay) | 거의 없음 | 폴링 주기만큼 늦어짐 |
| 구현 방식 | `select`, `poll`, `epoll`, callback 이벤트 | `sleep`, 무한 반복 루프, HTTP polling |
| 서버 구조 | Push 기반 (서버가 클라이언트에게 즉시 전달) | Pull 기반 (클라이언트가 계속 요청) |
| 실시간성 | 매우 좋음 | 보통 또는 낮음 |
| 확장성 | 높은 성능 (대량 사용자 처리 가능) | 낮음 (사용자가 많아지면 부하 증가) |
| 대표 예 | select 기반 채팅 서버, Node.js 이벤트 루프, WebSocket | 오래된 AJAX 1초 폴링 방식, 무한 루프 polling |

# 🤔 4장에대한 생각
- select 함수
  - 전체 FD를 검사한다는 것은 너무 비효율적인거 같다. 증권같은 속도가 중요한 시스템에서는 사용하면 안될 거 같다
  - epoll 함수를 사용해 이벤트가 발생한 FD만을 처리한다면 좀 더 효율적인 시스템을 만들 수 있을 거 같다.
- tcp_listen() 함수(헬퍼함수)
  - 이 함수를 쓴 이유가 무엇일까?
    1. 반복되는 코드를 제거하기 위해(socekt(),bind(),listen() 한번에 묶음)
    2. 에러 처리를 통합하여 깔끔하게 하기위해
    3. 가독성 향상을 위해
    4. 추가 기능을 넣기 쉽기에
  - 함수를 랩핑해두면 코드를 깔끔하고, 반복되는 작업을 캡슐화할 수 있기 때문에 아주 중요한 코드. 이런 헬퍼함수를 익숙하게 사용한다면 효율적이고 깔끔한 코드를 만들 수 있을것이다.
- FD_ISSET
  - server는 클라이언트수가 늘어남에 감시할 FD가 많아지지만, client는 키보다,server socket 2개만 감시하면된다
- select 기반 다중 입출력(I/O multiplexing) 서버 VS 논블록킹 소켓 기반 Busy-Polling 서버
  - 논블록킹 서버는 모든 소켓을 논블록킹으로 설정해 반복문 안에서 직접 recv/accept를 계속 호출하며 이벤트를 확인하는 방식이라 CPU 소모가 크고 구조는 단순한 반면, select 기반 서버는 select()가 읽기 가능한 소켓을 알려주기 때문에 필요한 소켓만 처리하여 CPU 효율은 높고 구조는 다소 복잡하지만 실무적
  - 논블록킹 Busy-Polling은 증권사에서 절대로 쓰이지 않음. cpu를 너무 많이 잡아먹고 사용자가 많아질수록부하가 많이 생기기에
  - select를 사용했지만 최근에는 epoll이 나와서 epoll을 사용한다고함
    
